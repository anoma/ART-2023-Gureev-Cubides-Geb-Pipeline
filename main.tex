\input{preambule}
\begin{document}
\input{metadata}

\begin{abstract}
At Heliax, we are developing a compiler stack to facilitate the creation
of decentralized applications using a high-level functional programming
language. This stack comprises a series of compilers that begin with
Juvix and culminate in arithmetic circuits, represented via Vamp-IR, an
intermediate language for such circuits. This report highlights the Geb
project, a component of this pipeline, detailing the process of compiling
Juvix Core into Vamp-IR through the Geb compiler. To aid its adoption and
implementation, we provide a categorical overview of the mathematical
foundations of the Geb project and insights into its current Lisp-based
implementation. The objective of this report is to guide future
implementations and improvements of the Geb project.
\end{abstract}


\begin{keywords}
Geb, Juvix, Vamp-IR
\end{keywords}
\maketitle
\section{Introduction}

The Geb project was initiated to compile functional programs into
high-level representation of arithmetic circuits via categorical methods.
This categorical approach specifies compilation procedures via internal language
theorems, thereby shifting focus from syntax to suitable categorical
structures. Additionally, phrasing compilation procedures in categorical
terms opens up easier methods for formal verification.

The core of the approach taken here rests on the observation that effective
compilation procedures, which preserve type structure (e.g., compilations
preserving lambda structure in languages derived from STLC), can be linked to
functors that maintain corresponding structures between categories
representing those programming languages.  One canonical example is that of Lambek-Scott, dealing with the fact that the languages possessing STLC structure form a category which is equivalent to the category of cartesian closed categories.

Therefore, instead of operating with syntax, we can represent our languages as distinct categories and construct functors between them. This approach simplifies their formalization due to the direct mathematical meaning of the constructions. Furthermore, functor properties inherently provide several beneficial features, including automatic type-checking for morphism composition.

The approach outlined in this document is supported by a reference implementation in Lisp. This Lisp-based Geb implementation signifies the project's initial completed stage: the compilation of functional programs written in Juvix Core language (regarded as an appropriate STLC extension) to VampIR, an in-house language for arithmetic circuits.
As part of the implementation, we also provide an interactive user environment equipped with extra features such as interpreters, program type-checkers, and a Geb visualizer available at the following address:
\begin{center}
    \url{https://github.com/anoma/geb}.
\end{center}

The general aim of the paper is to give an outlook of the pipeline design accessible to people without delving into Lisp code. Specifically, we aim to:

\begin{enumerate}
\item Make all components of the pipeline precise by describing their
intended semantics and paraphrasing the constructions in Agda/Haskell code
with explicit typing.
\item Describe all the compilation steps using diagrams for readability and
intelligibility.
\item  Highlight important features of the current implementation that are
worth porting outside the pipeline itself.
\end{enumerate}

We should mention beforehand that the paper uses terms from category theory and some theorems from categorical logic, but which are present solely for the sake of completeness. A person with adequate background will be able to grasp these in order to fully understand the mathematical background behind certain constructions, making e.g. the formally verifiable properties of certain compilation steps evident. However, many details can be skipped in favour of good presentation of the compilation procedure using diagrams.

\section{Language/Category Specs}

The central challenge is to effectively specify the compilation of
programs, written in a high-level functional programming language, into an
intermediate arithmetic circuit language. In the context of Heliax, this
corresponds to the translation from \Juvix{} to the \VampIR{} language, with a
specific focus on the compilation of \JuvixCore{} to \VampIR{}.
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJcXEp1dml4e30iXSxbMywxLCJcXFZhbXBJUnt9Il0sWzMsMCwiXFxKdXZpeENvcmV7fSJdLFswLDEsIiIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDJdLFsyLDFdXQ==
\[\begin{tikzcd}
	{\Juvix{}} &&& {\JuvixCore{}} \\
	&&& {\VampIR{}}
	\arrow[dashed, from=1-1, to=2-4]
	\arrow[from=1-1, to=1-4]
	\arrow[from=1-4, to=2-4]
\end{tikzcd}\]

\begin{itemize}
  \item \JuvixCore{}: A typed lambda-calculus incorporating inductive
  types and primitive integers, which defines the strict execution
  semantics of Juvix.
  \item \VampIR{}: An intermediate language for arithmetic circuit
  specification, akin to LLVM IR. It features useful constructors such as
  tuples, arrays, mapping and folds, currying, and circuit synthesis to
  Plonkup and Halo2.
\end{itemize}



The first step in this is to provide a good compilation from a sublanguage of Juvix, namely Juvix Core. The way we do this is by breaking up the procedure into compilations through languages we name \LambdaIR{}, \Geb{}, and \SeqN{}.

% https://q.uiver.app/#q=WzAsNSxbMCwwLCJcXG5vcm1hbHtKdXZpeCBDb3JlfSJdLFsyLDAsIlxcdGV4dHtMYW1iZGF9Il0sWzQsMCwiXFx0ZXh0e0dlYn0iXSxbNiwwLCJcXHRleHR7U2VxJFxcTiR9ICJdLFs4LDAsIlxcdGV4dHtWYW1wLUlSfSJdLFsxLDJdLFsyLDNdLFszLDRdLFswLDFdXQ==
\[\begin{tikzcd}
	{\text{Juvix Core}} && {\text{Lambda}} && {\text{Geb}} && {\text{Seq$\N$} } && {\text{Vamp-IR}}
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-5, to=1-7]
	\arrow[from=1-7, to=1-9]
	\arrow[from=1-1, to=1-3]
\end{tikzcd}\]

Here we are concerned only with the steps starting from \LambdaIR{}. The Juvix compiler already supports compiling Juvix Core to a suitable representation in Lambda barring the compilation of natural numbers, which is fairly straightforward. Hence the pipeline we will be interested in and the one written in Lisp is:

% https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXHRleHR7TGFtYmRhfSJdLFsyLDAsIlxcdGV4dHtHZWJ9Il0sWzQsMCwiXFx0ZXh0e1NlcSRcXE4kfSAiXSxbNiwwLCJcXHRleHR7VmFtcC1JUn0iXSxbMCwxXSxbMSwyXSxbMiwzXV0=
\[\begin{tikzcd}
	{\text{Lambda}} && {\text{Geb}} && {\text{Seq$\N$} } && {\text{Vamp-IR}}
	\arrow[from=1-1, to=1-3]
	\arrow[from=1-3, to=1-5]
	\arrow[from=1-5, to=1-7]
\end{tikzcd}\]

The current section is devoted to the specs of the languages used in the compilation with the Vamp-IR section devoted not to description of Vamp-IR themselves, but of the library of functions needed for any compiled code to compile on valid inputs. 

Let us provide a summary of the language characteristics of each language in the compiler stack, as initially presented in \cite{lukascz-vampir}.

\vspace*{2mm}
\begin{minipage}[b]{\hsize}\centering

\begin{tabular}{lllll}
\hline
\textbf{Feature} & \textbf{Juvix} & \textbf{JuvixCore} & \textbf{\Geb{}} & \textbf{\VampIR{}} \\ \hline
General recursion (functions)   &  Yes   &  Yes   &  No  &   No  \\
First-class functions   &  Yes   &  Yes   &  Yes  &   No\footnote{\VampIR{} higher-order and anonymous functions are not fully ``first-class'' because they cannot non-trivially interact with the field elements - they are essentially compilation-time-only.}  \\
Inductive data types  &  Yes   &  Yes   &  No  &   No  \\
Finite data structures  &  Yes   &  Yes   &  Yes\footnote{Encodable via products and coproducts.} & No\footnote{Pairs and lists in \VampIR{} cannot non-trivially interact with the field elements. In general, finite \JuvixCore{} data structures cannot be translated to them.}  \\
Prenex polymorphism  &  Yes   &  Yes   &  No  &  No\footnote{Polymorphic functions are supported, but not polymorphic data types which can interact non-trivially with field elements. Hence, monomorphisation is still necessary to translate from JuvixCore.} \\
Higher-rank polymorphism  &  Some   &  Yes   &  No  &   No  \\
Primitive integer type  &  Yes   &  Yes   &  No  &   Yes\footnote{\VampIR{} ``integers'' are the field elements, not integers strictly speaking.} \\
Runtime error reporting  &  Yes   &  Yes   &  No  &   No \\
\hline
\end{tabular}
% \caption{Language features}
\end{minipage}


\subsection{Geb}

The finite version of Geb implemented here has been formulated while trying to answer two things: 

1) What are the minimal/optimal operations needed to present polynomials which Vamp-IR operates with

2) What are the minimal/optimal bounding operations between functional programming languages

The answer seems to be that we need some sort of addition, multiplication, 0 and 1 as structures to be used. For the usual arithmetic to hold we also need some sort of a distributivity law. Exponentiation should follow just as we define arithmetic exponentiation from multiplication in usual arithmetic. (Of course multiplication can be defined similarly by addition, but it is not optimal to do so due to exponentiation of terms) Moreover, it seems that having explicit exponentiation in a language through which we compile is inefficient as it would need to compile to some separate Vamp-IR function. Finally, we need some notion of a "context" or a "domain" - as is usual in the syntax/semantics duality - in order to be able to produce variables.

Hence this brings us to a first definition of Geb

\begin{definition}
Geb is the language spanned by the empty type \tcbox{\normalfont{\texttt{so0}}}, unit type \gebterm \, and sum/product types appropriately named \gebcoprod \,  and \gebprod.
\end{definition}

%NOTE: For readibility makes sence to rename substmorph to some infix notation expressing arrows, otherwise it may be confusing to a lot of people

Here is a definition as one would write it in Agda:

\begin{minted}{agda}
data substobj : Set where
  so1 : substobj
  so0 : substobj
  coprod : substobj → substobj → substobj
  prod : substobj → substobj → substobj

data substmorph : substobj → substobj → Set where
   comp : {x y z : substobj} → (substmorph y z) → (substmorph x y) 
                                                → (substmorph x z) 
    -- composition
   id : (x : substobj) → (substmorph x x) 
   -- identity function
   initial : (x : substobj) → (substmorph so0 x) 
   -- absurd 
   terminal : (x : substobj) → (substmorph x so1) -- constant function
   mcase : {x y z : substobj} → (substmorph x z) → (substmorph y z) 
                                                 → ((coprod x y) ↦ z)
   -- casing 
   prod : {x y z : substmorph} → (substmorph z x) → (substmorph z y) 
                                                  → (substmorph z (prod x y))
    -- product analysis
   distribute : {x y z : substobj} → (substmorph (prod x  (coprod y z)) 
                                                  (coprod (prod x y) (prod x z)))
    -- distributivity
   ->left : {x y : substobj} → (substmorph x  (coprod x y))
    -- left injection
   ->right : {x y : substobj} → (substmorph y (coprod x y))
    -- right injection
   <-left : {x y : substobj} → (substmorph (prod x y) x)
    -- left projection
   <-right : {x y : substmorph} → (substmorph (prod x y) y) 
    -- right projection
\end{minted}

Here \gebobj is the collection of the types of our language and \tcbox{\texttt{f : substmorph a b}} for a term of \tcbox{\texttt{b}} in context of \tcbox{\texttt{a}}. There are of course extra equalities to subject the terms to, making terminal terms unique or composition associative on the nose e.g., yet for the sake of the current project, we do not implement these and if needed, reductions are done by hand. There is also an explicit reducer in development.

Another way to think about Geb is to instead specify the categorical structure instead of the syntactical one, namely:
\begin{definition}
\text{Geb} is the category freely spanned by an initial object so0, terminal object so1 and finite (co)products alongside the distributivity axiom.
\end{definition}

Recall that a category of models of a language $\mathbf{L}$ is a category whose objects are models of $\mathbf{L}$ and morphisms being mappings preserving said language structure (\textit{e.g. category of models of groups is the category of groups and group morphisms)}. The above definition corresponds to considering the term model of a language, namely the initial category of its corresponding category of models.

However, the semantics of this definition are a bit unclear. Note that taking coproducts with $\gebinit$ is equivalent to the identity functor (like adding 0 is the same as the identity function) while taking products with $\gebinit$ to a constant functor at $\gebinit$ (distributive categories have strict initial objects, so similar to how multiplying by 0 gives 0). Similarly, taking products with $\gebterm$ is equivalent to the identity functor (like multiplying by 1 gives back the original term). So - intuitively - the only way to make "new" types in Geb is by taking coproducts of $\gebterm$ with itself over and over. There is actually a category which is specified by being generated filtered colimits over inclusions between such coproducts of the terminal object: FinSet. It is indeed generated by just adding extra 1-element sets to the empty set. So here is the third definition:

\begin{definition}
\Geb{} is \FinSet{}.
\end{definition}

Let us make this correspondence exact:

\begin{theorem}
\FinSet{} is an initial weak model of the \Geb{} language. That is, it is equivalent to the initial model of the essentially algebraic theory of category theory with initial, terminal objects, finite (co)products structure and distributivity and the equivalence preserves all relevant categorical structure.  
\end{theorem}

\begin{proof}
We can instead deal with $Sk(\FinSet{}) = \FinOrd{}$, the category of finite ordinals as clearly the equivalence preserves all relevant structure. Now suppose $(C, 1_C, 0_C, +_C, \times_C)$ is a distributive category with initial/terminal object. 

Note that $\bigoplus_{n} 1_C \times_C \bigoplus_m 1_C = \bigoplus_{n \times
m} 1_C$ by induction on $n$: when $n=0$ since initial object is strict the
product is just $0_C$ which is also the null coproduct. The inductive step
follows.

\begin{align*}
\bigoplus_{1+n} 1_C \times_C \bigoplus_{m} 1_C &\cong (\bigoplus_n 1_C +_C 1_C) \times_C \bigoplus_m 1_C   &\text{(By ?)} \\
&\cong (\bigoplus_n 1_C \times_C \bigoplus_m 1_C)  +_C  \bigoplus_m 1_C ) &\text{(By distributivity prop.)} \\
&\cong \bigoplus_{n \times m} 1_C + \bigoplus_m 1_C &\text{(By induction hypothesis on $n$)}\\
&\cong \bigoplus_{(1+n) \times m} 1_C .
\end{align*}

Recall that both \FinSet{} and \FinOrd{} constitute the weakly initial category,
each spanning on a single object by finite coproducts. Given that $C$ has
coproducts and $1_C$, we can establish the morphism $F \colon Ord \to C$,
which preserves this structure along with the terminal object. Note that
the product structure is also preserved. Given $n \times m$ proceed by
induction on $n$: 

\begin{itemize}
    \item If $n= 0$, then we have,
         $$F(0 \times m) = F(0) \cong 0_C \cong 0_C \times_C F(m) \cong F(0) \times_C F(m).$$
    \item For the inductive step, we use the previous observation:

\begin{align*}
    F((1+n) \times m) &= F((n \times m) + m) \\
    &\cong (F(n) \times_C F(m)) +_C F(m) &\text{(By induction and $F$ preserves coproducts)} \\
    &\cong (\bigoplus_n 1_C \times_C \bigoplus_m 1_C) +_C \bigoplus_m 1_C &\text{(By definition of $F$)}\\
    &\cong \bigoplus_{n \times m} 1_C + \bigoplus_m 1_C \\
    &\cong \bigoplus_{(1+n) \times m} 1_C \\
    &\cong \bigoplus_{1+n} 1_C \times_C \bigoplus_m 1_C \\
    &\cong F(1+n) \times F(m)
\end{align*}
\end{itemize}

Since everything the functor hits is a coproduct of the terminal object up to an isomorphism and $F$ preserves all coporduct structure, it preserves all other morphism structure, including product universal morphisms and distributivity, i.e. it is an actual functor of models.

By the same argument, since everything the functor hits is a coproduct of $1_C$ and $F$ preserves coproduct structure and is a unique functor doing so up to natural iso, this also proves uniqueness up to iso.


\end{proof}

Hence Definition 3 is fully valid and when one talks of Geb, one can instead think about a nice presentation of FinSet. Hence a term of $\gebobj$ is just a finite set and a term of \tcbox{\texttt{substmorph a b}} is just a function between corresponding finite sets. As expected, this equivalence actually provides us with the existence of a lot of extra structure.

\begin{corollary}
Geb is cartesian closed.
\end{corollary}

That is, for any two objects \tcbox{\texttt{a, b : substobj}} we get an object \tcbox{\texttt{(sohomobj a b) : substobj}} which is an object of Geb representing all terms of \tcbox{\texttt{b}} in context \tcbox{\texttt{a}}, or, in other words, it is the function type from type \tcbox{\texttt{a}} to type \tcbox{\texttt{b}}. It also comes equipped with the usual curry isomorphism and evaluation maps:

\begin{minted}{agda}
curry : {a b c : substobj} → (substmorph (prod a b) c) 
                           → (substmorph a (sohomobj b c))
eval : {a b : substobj} → (substmorph (sohomobj a b) a) → b
uncurry : {a b c : substobj} → (substmorph a (sohomobj b c)) 
                             → (substmorph (prod a b) c)
\end{minted}

The actual implementation of said types is not of importance for the report but we need these functions in order to compile Juvix code to Geb, which is why these are mentioned. 

With the recent changes, we have also upgraded Geb to be able to express compactly natural number integers of fixed width. The way we do it is by the evident trick: consider all n-bit wide numbers. Evidently there are $2^n$ of these, which means that their set is in bijection with the finite ordinal of cardinality $2^n$. In other words, we introduce objects $nat-width n$ for every $n > 0$ which are really just isomorphic copies of $2^n$ coproducts of $\gebterm$. So Geb already had the natural number functionality, it was just highly inefficient before introducing explicit constructors.

% Jona: continue here
Hence we also need to add to Geb constructors:

\begin{minted}{agda}
data substobj : Set where
...
nat-width : Nat → substobj -- nat-width n is the set of n-bit natural numbers

data substmorph : substobj → substobj → Set where
...
nat-add : (n : Nat) → substmorph (nat-width n) (nat-width n) 
--addition
nat-mult : (n : Nat) → substmorph (nat-width n) (nat-width n)
--multiplication
nat-sub : (n : Nat) → substmorph (nat-width n) (nat-width n)
--subtraction
nat-div : (n : Nat) → substmorph (nat-width n) (nat-width n) 
--division 
nat-concat : (n m : Nat) → (substmorph (prod (nat-width n) (nat-width m))
                                       (nat-width (n+m))) 
-- concatenation of bits
nat-inj : (n : Nat) → (substmorph (nat-width n) (nat-width (n + 1)))
nat-decompose : (n : Nat) → (substmorph (nat-width (n + 1)) 
                                        (prod (nat-width 1) (nat-width n)))
-- decomposes an n+1 bit number into the top bit and the rest of the bits
one-bit-to-bool : substmorph  (nat-width 1) (coprod so1 so1)
-- isomorphism sending bit 0 to the left copy of so1, and 1 to the right copy.
nat-eq : (n : Nat) → (substmorph (prod (nat-width n) (nat-width n)) 
                                 (coprod so1 so1))
--equality predicate
nat-lt : (n : Nat) → (substmorph (prod (nat-width n) (nat-width n))
                                  (coprod so1 so1))
--"less-than" predicate
\end{minted}

WIth this, we have described all the relevant specs of Geb for the current report. However, there are a few things to note:

Firstly, one needs to be careful when using the term "Geb" as it can point to many things. The Geb language as it is currently implemented in the pipeline is just a subcomponent of what the final version of Geb will look like. The intention is that Geb will become a language that will be able to articulate the entirety of the pipeline currently presented in CL. The reason why we call this category Geb here is because this category will be a core component specifying the higher-order Geb category, which itself will correspond to a larger programming language. However in this report we always use "Geb" to describe Geb as given in Definitions 1-3.

Secondly, note that while the code written for Geb has the same intended semantics as the Lisp code for Geb, it is indeed different, as the Lisp code is untyped. So composition does not automatically type-check and we frequently have no knowledge of which types are used, e.g. when we are presented with a curried function as these just reduce to some product/coproduct operations. Hence we will, e.g. introduce an explicit function type in Lambda in order to optimize certain outputs. Also note that $\tcbox{id}$ is not an actual function in the Lisp implementation, instead we use just the names of the objects.
 
\subsection{Lambda}

The Lambda language is but an extended version of simply-typed lambda calculus (STLC) with types taken from Geb. The latter part is the reason why we described Geb before talking about Lambda, even if the compilation order is different. However the terms are introduced untyped first and become typed once the context is introduced via a specific functions such as \tcbox{ann-term}.
\begin{definition}
    Lambda is STLC with types from \gebobj extended by the error terms \lamerr of arbitrary type as well as fix bit-width natural number arithmetic.
\end{definition}

Here is the definition as one would type it in Agda:

\begin{minted}{agda}
data lambda : Set where
absurd : substobj → lambda   
-- beta reduction for empty type
unit : lambda     -- unique element of unit type so1
left : substobj → lambda → lambda  
-- left inclusion into coproduct
right : substobj → lambda → lambda 
-- right inclusion into comporoduct
case-on : lambda → lambda → lambda → lambda 
-- beta elimination for coproducts
pair : lambda → lambda → lambda 
-- term introduction for products
fst : lambda → lambda   
-- left projection
snd : lambda → lambda   
-- right projection
lamb : (List substobj) → lambda → lambda 
-- function type term introduction
-- takes in a list of types for iterated function type use
app : lambda → (List lambda) → lambda 
-- function type elimination
--takes in a list of terms for iterated elimination
index : Nat → lambda  
-- variable via de Bruijn indices
err : substobj → lambda 
-- error term of arbitrary type
plus : lambda → lambda → lambda 
-- arithmetic operations
times : lambda → lambda → lambda
minus : lambda → lambda → lambda
divide : lambda → lambda → lambda
bit-choice : (List bool) → lambda 
-- natural number choice
lamb-eq : lambda → lambda → lambda 
-- equality of natural numbers
lamb-lt : lambda → lambda → lambda 
-- "less-than" predicate on natural numbers
\end{minted}

Of course a lot of the terms produced this way will be ill-typed. E.g. indices in an empty context are ill-defined. So, as mentioned before, we have functionality of typing the terms of \tcbox{\texttt{lambda}}, namely the function \tcbox{ann-term} as in the Lisp implementation each term has a slot for types which we fill in recursively. We also have a \tcbox{well-defp} predicate checking whether a given Lambda term is well-defined as per usual typing rules, e.g. checkimg that  There are two things that need to be noted: 

\begin{enumerate}
    \item All the arithmetic operation terms are deemed well-typed iff the provided terms are of same bit-width
    \item The natural number predicates are all bool-valued, i.e. their type is \tcbox{\texttt{coprod so1 so1}}
\end{enumerate}

\subsection{Seq$\N$}
\SeqN{} is a category whose intended semantics are as follows:

The objects of \SeqN{} are finite sequences of natural numbers $(x_1,...,x_n)$. A morphism $f : (x_1,...,x_n) \to (y_1,...,y_m)$ is a Vamp-IR function that takes in $n$ with the i'th entry being of bit-size $x_i$ and outputs an $m$-tuple with i'th entry being of bit-size $y_i$. Hence it makes sense to call it a category of Vamp-IR programs. 

However, we do not yet have a precise specification of Vamp-IR as it is still in active development, what we are aiming for is simply to specify some subcategory of the one described above which will be sufficient for interpreting faithfully all the Geb programs we have.

Instead of a nice definition, hence, we have an explicit definition of \SeqN in terms of a free category spanned by the following objects/morphisms:

\begin{minted}{agda}
SeqNObj = List Nat

data SeqNMorph : SeqNObj → SeqNObj → Set where
composition : {a b c: SeqNObj} → SeqNMorph b c →  SeqNMorph a b → SeqNMorph a c
--composition
id : {a : SeqNMorph} → SeqNMorph a a
--identity
fork-seq : {a : SeqNObj} SeqNMorph a (append a a)
--morphism coppying the entry twice
parallel-seq : {a b c d : SeqNObj} →  SeqNObj a b →  SeqNObj c d 
                                  → SeqNObj (append a c) (append b d)
-- given two functions, parallizes them                                
drop-nil : (a  SeqNObj) →  SeqNMorph a (0 :: [])
-- given an object, just drops everything to a nil entry
remove-right : (a : SeqNObj) → SeqNMorph (append a (0 :: [])) a
-- removes a right-positioned zero entry
remove-left : (a : SeqNObj) → SeqNMorph (append (0 :: []) a) a
-- removes a left-positioned zero entry
drop-width : (a b : SeqNObj) → SeqNMorph a b
-- on entry, removes extra bits as needed
inj-length-left : (a b : SeqNObj) → SeqNMorph a (append a b)
-- injects an entry producing nothing on the right side
inj-length-left : (a b : SeqNObj) → SeqNMorph b (append a b)
-- injects an entry producing nothing on the left side
inj-size : (a b : Nat) → SubstMorph (a :: []) (b :: [])
-- same as inject size for single entries
branch-seq : {a b : SeqNObj} → SeqNMorph a b →  SeqnMorph a b → SeqnMorph (1 :: a) b
zero-bit : SeqNMorph (0 :: []) (1 :: [])
-- produces 0
one-bit : SeqNMorph (0 :: []) (1 :: [])
-- produces 1
shift-front : ((x_1 :: ... :: x_n) : SeqNObj) →  (k : Nat) 
             →  SeqNMorph (x_1 :: ... :: x_n) (x_k :: x_1 ... x_k-1 :: x_k+1 :: ...)
-- shifts the k-th entry in front
seqn-add : (n : Nat) → SeqNMorph (n :: n :: 0) (n :: 0)
-- basic arithmetic operations
seqn-subtract : (n : Nat) → SeqNMorph (n :: n :: 0) (n :: 0)
seqn-multiply : (n : Nat) → SeqNMorph (n :: n :: 0) (n :: 0)
seqn-divide : (n : Nat) → SeqNMorph (n :: n :: 0) (n :: 0)
seqn-nat :: (n m : Nat) → SeqNMorph (0 :: []) (n :: [])
-- produces an n-wide natural number m
seqn-concat : (n m : Nat) → SeqNMorph (n :: m :: []) ((n + m) :: [])
-- concatenates two n and m wide bits
seqn-decompose : (n : Nat) → SeqNMorph (n :: []) (1 :: (n - 1) :: [])
-- takes the top bit off of the input and palces it in separate slot
seqn-eq : (n : Nat) → SeqNMorph (n :: n :: []) (1 :: 0 :: [])
-- equality predicate
seqn-lt : (n : Nat) → SeqNMorph (n :: n :: []) (1 :: 0 :: [])
-- less than predicate
\end{minted}

One may note that there was pseudocode used for \tcbox{seqn-shift} morphism in order to facilitate readibility and that the predicates takes values in $(1, 0)$ rather than in just $(1)$ as would be expected. The latter fact is due to way we interpret coproduct from Geb in \SeqN. We will be discussing this in detail in the next section.

\subsection{Vamp-IR}

Vamp-IR is the intermediary language for arithmetic circuits. As the final point of the compilation, it does not need to be fully specified by the pipeline (even we do have the spec in the code covering some principal aspects). The only thing we practically need is a collection of functions we will be using in the compilation procedure which we provide below:

\begin{minted}{rust}

def bool x = { x*(x-1) = 0 ; x};

def base_range 0 = {
  []
};

def next_range range a = {
  def a0 = bool (fresh (a % 2));
  def a1 = fresh (a \ 2);
  a0 : (range a1)
};

def range_n n = {
  iter n next_range base_range
};

def hd (h:t) = {
  h
};

def tl (h:t) = {
  t
};

def n_th lst n = {
  hd (iter n tl lst)
};

def negative n a = {
  nth (range_n (n + 1) (a + (2 ^ n))) n
};

def plus_range n x1 x2 = {
  range_n n (x1 + x2);
  x1 + x2
};

def mult_range n x1 x2 = {
  mult_range n (x1 * x2);
  x1 * x2
};

def minus_range n x1 x2 = {
  negative n (x1 - x2) = 1;
  x1 - x2
};

def iszero a = {
  def ai = fresh (1 | a);
  def b = 1 - (ai * a);
  a * b = 0;
  1 - b
};

def combine-aux x y = {
  x + (2 * y)
};

def combine xs = {
  fold xs combine_aux 0
};

def take_base lst = {
  []
};

def take_ind take (h:t) = {
  h:(take t)
};

def take n = {
  iter n take_ind take_base
};

def drop_ith_rec take (h:t) = {
  h:(take t)
};

def drop_ith n = {
  iter n drop_ith_rec (fun (h:1) {1})
};
\end{minted}

\section{Compilation Steps}

After providing the specs of intermediary languages we compile through, we are ready to sketch the design of the pipeline itself. Diagramatically, recall that it looks something like this:

% https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXHRleHR7TGFtYmRhfSJdLFsyLDAsIlxcdGV4dHtHZWJ9Il0sWzQsMCwiXFx0ZXh0e1NlcSRcXE4kfSAiXSxbNiwwLCJcXHRleHR7VmFtcC1JUn0iXSxbMCwxLCJcXHRleHR7dG8tY2F0fSJdLFsxLDIsIlxcdGV4dHt0by1zZXFufSJdLFsyLDMsIlxcdGV4dHt0by1jaXJjdWl0fSJdXQ==
\[\begin{tikzcd}
	{\text{Lambda}} && {\text{Geb}} && {\text{Seq$\N$} } && {\text{Vamp-IR}}
	\arrow["{\text{to-cat}}", from=1-1, to=1-3]
	\arrow["{\text{to-seqn}}", from=1-3, to=1-5]
	\arrow["{\text{to-circuit}}", from=1-5, to=1-7]
\end{tikzcd}\]

The compilations are appropriately named \tcbox{to-cat}, \tcbox{to-seqn}, \tcbox{to-circuit} after their codomains. Actually \tcbox{to-seqn} \, and \tcbox{to-circuit} are also generics, so that their names stand for various compilations depending on what code we feed that. For example, \tcbox{to-seqn}is originally a compilation from Geb to Seq$\N$, yet if we feed it Lambda code, it will actually compile (with certain specific settings) that code to Seqn$\N$ by first applying \tcbox{to-cat} and then the original to-seqn. Simialrly for \tcbox{to-circuit}. Hence the full-on diagram is:


% https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXHRleHR7TGFtYmRhfSJdLFsyLDAsIlxcdGV4dHtHZWJ9Il0sWzQsMCwiXFx0ZXh0e1NlcSRcXE4kfSAiXSxbNiwwLCJcXHRleHR7VmFtcC1JUn0iXSxbMCwxLCJcXHRleHR7dG8tY2F0fSJdLFsxLDIsIlxcdGV4dHt0by1zZXFufSJdLFsyLDMsIlxcdGV4dHt0by1jaXJjdWl0fSJdLFswLDIsIlxcdGV4dHt0by1zZXFufSIsMSx7ImN1cnZlIjoyfV0sWzAsMywiXFx0ZXh0e3RvLWNpcmN1aXR9IiwyLHsiY3VydmUiOjV9XSxbMSwzLCJcXHRleHR7dG8tY2ljcnVpdH0iLDAseyJjdXJ2ZSI6LTV9XV0=
\[\begin{tikzcd}
	{\text{Lambda}} && {\text{Geb}} && {\text{Seq$\N$} } && {\text{Vamp-IR}}
	\arrow["{\text{to-cat}}", from=1-1, to=1-3]
	\arrow["{\text{to-seqn}}", from=1-3, to=1-5]
	\arrow["{\text{to-circuit}}", from=1-5, to=1-7]
	\arrow["{\text{to-seqn}}"{description}, curve={height=12pt}, from=1-1, to=1-5]
	\arrow["{\text{to-circuit}}"', curve={height=30pt}, from=1-1, to=1-7]
	\arrow["{\text{to-cicruit}}", curve={height=-30pt}, from=1-3, to=1-7]
\end{tikzcd}\]

The use of the pipeline interactively is best done through the \tcbox{lambda} package. One can see how the interpretation of the identity function goes through.

\begin{minted}{lisp}
CL-USER> (in-package geb.lambda.trans)
#<PACKAGE "GEB.LAMBDA.TRANS">
TRANS> (to-cat nil (lamb (list (coprod so1 so1)) (index 0)))
(<-left (+ s-1 s-1) s-1)
TRANS> (to-seqn (lamb (list (coprod so1 so1)) (index 0)))
(COMPOSITION (REMOVE-RIGHT (1 0)) (PARALLEL-SEQ (ID (1 0)) (DROP-NIL (0))))
TRANS> (to-circuit (lamb (list (coprod so1 so1)) (index 0)) :identity_fun)
(def identity_fun x1 x2 x3 = {
   range_n 0 x3;
   range_n 0 x2;
   range_n 1 x1;
   (x1)
 };)

\end{minted}

Here the \tcbox{nil} stands for the empty context we feed the compiler when we move from Lambda to Geb. All other compilations are assumed to occur in the empty context. Also \tcbox{to-circuit} demands a name for the function to compile. 

In the proceeding discussion all possible info is replaced by categorical counterparts for readibility. So \gebprod will be denoted by $\times$, \gebcoprod by $+$, elements of \gebmorph by actual arrows etc everywhere where deemed possible without losing information. Similarly \tcbox{sohomobj} will now be denoted by explicit arrows. 

\subsection{Lambda $\to$ Geb}
The core part of the compilation from Lambda to Geb is actually a canonical one that can be seen as instead the initial morphism from the term model of the Lambda language to Geb in the category of models of STLC. Here we are simply showcasing the compilation of a specific part of that category, namely what one in semantics of type theories would call "terms", namely sections to canonical projection maps.

The description of the compilation will be made less formal to facilitate understanding and lambda and function application terms will be assumed to be 1-argument only.

 We define the compilation to-cat $\colon$ (List \gebobj) $\times$ Lambda $\to$ Geb as a function taking in a lambda term and a context and spitting out a Geb morphism with typing $$\textnormal{to-cat} (A_1,...,A_n) (term : B) : A_1 \times ...\times A_n \times \textnormal{so1} \to B $$

 We proceed by induction assuming that we are always given context $A_1,...,A_n := \Gamma$ :

\begin{enumerate}
    \item We compile \tcbox{(absurd B (term : so0))} to
  % https://q.uiver.app/#q=WzAsMyxbMCwwLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIlxcdGV4dHtzbzB9Il0sWzQsMCwiQiJdLFswLDEsIlxcc2NyaXB0c2l6ZXtcXHRleHRub3JtYWx7dG8tY2F0fSAoXFxHYW1tYSkodGVybSl9Il0sWzEsMiwiIV9CIl1d
\[\begin{tikzcd}
	{A_1\times...\times A_n \times \text{so1}} && {\text{so0}} && B
	\arrow["{\scriptsize{\textnormal{to-cat} (\Gamma)(term)}}", from=1-1, to=1-3]
	\arrow["{!_B}", from=1-3, to=1-5]
\end{tikzcd}\]
\item We compile \tcbox{(unit : so1)} to
% https://q.uiver.app/#q=WzAsMixbMCwwLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsInNvMSJdLFswLDEsIiFfe0FfMVxcdGltZXMuLi5BX25cXHRpbWVzIFxcdGV4dHtzbzF9fSJdXQ==
\[\begin{tikzcd}
	{A_1\times...\times A_n \times \text{so1}} && so1
	\arrow["{!_{A_1\times...A_n\times \text{so1}}}", from=1-1, to=1-3]
\end{tikzcd}\]
\item We compile \tcbox{(left A (term : B) : A + B)} to
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIkIiXSxbNCwwLCJCK0EiXSxbMCwxLCJcXHNjcmlwdHNpemV7XFx0ZXh0e3RvLWNhdH0gKFxcR2FtbWEpKHRlcm0pfSJdLFsxLDIsIlxcdGV4dHstPmxlZnR9IiwwLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoiaG9vayIsInNpZGUiOiJ0b3AifX19XV0=
\[\begin{tikzcd}
	{A_1\times...\times A_n \times \text{so1}} && B && {B+A}
	\arrow["{\scriptsize{\text{to-cat} (\Gamma)(term)}}", from=1-1, to=1-3]
	\arrow["{\text{->left}}", hook, from=1-3, to=1-5]
\end{tikzcd}\]
\item We compile \tcbox{(right A (term : B)) : A + B} to
% https://q.uiver.app/#q=WzAsMyxbMCwwLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIkIiXSxbNCwwLCJBK0IiXSxbMCwxLCJcXHNjcmlwdHNpemV7XFx0ZXh0e3RvLWNhdH0gKFxcR2FtbWEpKHRlcm0pfSJdLFsxLDIsIlxcdGV4dHstPnJpZ2h0fSIsMCx7InN0eWxlIjp7InRhaWwiOnsibmFtZSI6Imhvb2siLCJzaWRlIjoidG9wIn19fV1d
\[\begin{tikzcd}
	{A_1\times...\times A_n \times \text{so1}} && B && {A+B}
	\arrow["{\scriptsize{\text{to-cat} (\Gamma)(term)}}", from=1-1, to=1-3]
	\arrow["{\text{->right}}", hook, from=1-3, to=1-5]
\end{tikzcd}\]
\item We compile \tcbox{(case-on (on : A + B) (ltm : C) (rtm : C) : C} to
% https://q.uiver.app/#q=WzAsNCxbMCwyLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFswLDAsIihBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSkgXFx0aW1lcyAoQSArQikiXSxbMSwwLCIoQV8xXFx0aW1lcy4uLlxcdGltZXMgQV9uIFxcdGltZXMgXFx0ZXh0e3NvMX0gXFx0aW1lcyBBKSArIChBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSBcXHRpbWVzIEIpIl0sWzEsMiwiQyJdLFswLDEsIlxcc2NyaXB0c2l6ZXtcXHRleHR7dG8tY2F0fSAoXFxHYW1tYSkodGVybSl9Il0sWzEsMiwiXFx0ZXh0e2Rpc3RyaWJ1dGV9Il0sWzIsMywiXFxzY3JpcHRzaXplW1xcdGV4dHt0by1jYXR9KFxcR2FtbWEpKGx0bSkpLCBcXHRleHR7dG8tY2F0fShcXEdhbW1hKShydG0pXSJdXQ==
\[\begin{tikzcd}
	{(A_1\times...\times A_n \times \text{so1}) \times (A +B)} & {(A_1\times...\times A_n \times \text{so1} \times A) + (A_1\times...\times A_n \times \text{so1} \times B)} \\
	\\
	{A_1\times...\times A_n \times \text{so1}} & C
	\arrow["{\scriptsize{\text{to-cat} (\Gamma)(term)}}", from=3-1, to=1-1]
	\arrow["{\text{distribute}}", from=1-1, to=1-2]
	\arrow["{\scriptsize[\text{to-cat}(\Gamma)(ltm)), \text{to-cat}(\Gamma)(rtm)]}", from=1-2, to=3-2]
\end{tikzcd}\]
\item We compile \tcbox{(pair (ltm : A) (rtm : B)) : A $\times$ B} to
% https://q.uiver.app/#q=WzAsMixbMCwwLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFs0LDAsIkEgXFx0aW1lcyBCIl0sWzAsMSwiXFxzY3JpcHRzaXplXFxsYW5nIFxcdGV4dHt0by1jYXR9KFxcR2FtbWEpKGx0bSksIFxcdGV4dHt0by1jYXR9KFxcR2FtbWEpKHJ0bSkgXFxyYW5nIl1d
\[\begin{tikzcd}[column sep=large]
	{A_1\times...\times A_n \times \text{so1}} &&&& {A \times B}
	\arrow["{\scriptsize\langle \text{to-cat}(\Gamma)(ltm), \text{to-cat}(\Gamma)(rtm) \rangle}", from=1-1, to=1-5]
\end{tikzcd}\]
 \item We compile \tcbox{(fst (term : A $\times$ B)) : A} to
% https://q.uiver.app/#q=WzAsMyxbMCwxLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIkEgXFx0aW1lcyBCIl0sWzIsMSwiQSJdLFswLDEsIlxcc2NyaXB0c2l6ZSBcXHRleHR7dG8tY2F0fSAoXFxHYW1tYSkodGVybSkiXSxbMSwyLCJcXHBpXzEiXV0=
\[\begin{tikzcd}[column sep=large]
	&& {A \times B} \\
	{A_1\times...\times A_n \times \text{so1}} && A
	\arrow["{\scriptsize \text{to-cat} (\Gamma)(term)}", from=2-1, to=1-3]
	\arrow["{\pi_1}", from=1-3, to=2-3]
\end{tikzcd}\]
\item We compile \tcbox{(snd (term : A $\times$ B)) : B} to
% https://q.uiver.app/#q=WzAsMyxbMCwxLCJBXzFcXHRpbWVzLi4uXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIkEgXFx0aW1lcyBCIl0sWzIsMSwiQiJdLFswLDEsIlxcc2NyaXB0c2l6ZSBcXHRleHR7dG8tY2F0fSAoXFxHYW1tYSkodGVybSkiXSxbMSwyLCJcXHBpXzIiXV0=
\[\begin{tikzcd}[column sep=large]
	&& {A \times B} \\
	{A_1\times...\times A_n \times \text{so1}} && B
	\arrow["{\scriptsize \text{to-cat} (\Gamma)(term)}", from=2-1, to=1-3]
	\arrow["{\pi_2}", from=1-3, to=2-3]
\end{tikzcd}\]
\item We compile \tcbox{(lamb (tdom : A) (term : B)) : A $\to$ B} to the curried morphism below
% https://q.uiver.app/#q=WzAsNCxbMCwwLCJBIFxcdGltZXMgQV8xXFx0aW1lcy4uLlxcdGltZXMgQV9uIFxcdGltZXMgXFx0ZXh0e3NvMX0iXSxbMiwwLCJCIl0sWzAsMiwiQV8xIFxcdGltZXMgLi4uIFxcdGltZXMgQV9uIFxcdGltZXMgXFx0ZXh0e3NvMX0iXSxbMiwyLCIoQSBcXHRvIEIpIl0sWzAsMSwiXFxzY3JpcHRzaXplIFxcdGV4dHt0by1jYXR9IChBLFxcR2FtbWEpKHRlcm0pIl0sWzIsMywiXFxzY3JpcHRzaXplIFxcdGV4dHtjdXJyeX0oXFx0ZXh0e3RvLWNhdH0gKEEsXFxHYW1tYSkodGVybSkpIl0sWzQsNSwiXFx0ZXh0e2N1cnJ5fSIsMSx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sImxldmVsIjoxLCJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJtYXBzIHRvIn0sImJvZHkiOnsibmFtZSI6ImRvdHRlZCJ9fX1dXQ==
\[\begin{tikzcd}[sep=large]
	{A \times A_1\times...\times A_n \times \text{so1}} && B \\
	\\
	{A_1 \times ... \times A_n \times \text{so1}} && {(A \to B)}
	\arrow[""{name=0, anchor=center, inner sep=0}, "{\scriptsize \text{to-cat} (A,\Gamma)(term)}", from=1-1, to=1-3]
	\arrow[""{name=1, anchor=center, inner sep=0}, "{\scriptsize \text{curry}(\text{to-cat} (A,\Gamma)(term))}", from=3-1, to=3-3]
	\arrow["{\text{curry}}"{description}, shorten <=9pt, shorten >=9pt, dotted, maps to, from=0, to=1]
\end{tikzcd}\]
\item We compile \tcbox{(app (fun : A $\to$ B) (term : A) :B} to
% https://q.uiver.app/#q=WzAsMyxbMCwxLCJBXzEgXFx0aW1lcyAuLi4gXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIihBIFxcdG8gQikgXFx0aW1lcyBBIl0sWzIsMSwiQiJdLFswLDEsIlxcc2NyaXB0c2l6ZVxcbGFuZ2xlIFxcdGV4dHt0by1jYXR9KFxcR2FtbWEpKFxcdGV4dHtmdW59KSwgXFx0ZXh0e3RvLWNhdH0oXFxHYW1tYSkodGVybSlcXHJhbmdsZSJdLFsxLDIsIlxcdGV4dHtldmFsfSJdXQ==
\[\begin{tikzcd}[sep=large]
	&& {(A \to B) \times A} \\
	{A_1 \times ... \times A_n \times \text{so1}} && B
	\arrow["{\scriptsize\langle \text{to-cat}(\Gamma)(\text{fun}), \text{to-cat}(\Gamma)(term)\rangle}", from=2-1, to=1-3]
	\arrow["{\text{eval}}", from=1-3, to=2-3]
\end{tikzcd}\]
\item We compile \tcbox{(index i) : $A_i$} to
% https://q.uiver.app/#q=WzAsMixbMCwwLCJBXzEgXFx0aW1lcyAuLi4gXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIkFfaSJdLFswLDEsIlxccGlfbiJdXQ==
\[\begin{tikzcd}[sep=large]
	{A_1 \times ... \times A_n \times \text{so1}} && {A_i}
	\arrow["{\pi_n}", from=1-1, to=1-3]
\end{tikzcd}\]
\item We compile \tcbox{(plus (ltm : nat-width n) (rtm : nat-width n)) : nat-width n} to
% https://q.uiver.app/#q=WzAsMyxbMCwxLCJBXzEgXFx0aW1lcyAuLi4gXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIihcXHRleHR7bmF0LXdpZHRoIG59KVxcdGltZXMgXFx0ZXh0eyhuYXQtd2lkdGggbil9Il0sWzIsMSwiXFx0ZXh0eyhuZXQtd2lkdGggbil9Il0sWzAsMSwiXFxzY3JpcHRzaXplIFxcbGFuZ2xlIFxcdGV4dHt0by1jYXR9KFxcR2FtbWEpKGx0bSkgLCBcXHRleHR7dG8tY2F0fSAoXFxHYW1tYSkocnRtKSBcXHJhbmdsZSJdLFsxLDIsIlxcdGV4dHtuYXQtYWRkfSJdXQ==
\[\begin{tikzcd}[sep=large]
	&& {(\text{nat-width n})\times \text{(nat-width n)}} \\
	{A_1 \times ... \times A_n \times \text{so1}} && {\text{(net-width n)}}
	\arrow["{\scriptsize \langle \text{to-cat}(\Gamma)(ltm) , \text{to-cat} (\Gamma)(rtm) \rangle}", from=2-1, to=1-3]
	\arrow["{\text{nat-add}}", from=1-3, to=2-3]
\end{tikzcd}\]
and similarly with other arithmeic operations. 
\item We compile \tcbox{(bit-choice bitv : nat-width n} where bitv is of length n and has a representation as natural number m:

% https://q.uiver.app/#q=WzAsMyxbMCwxLCJBXzEgXFx0aW1lcyAuLi4gXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIlxcdGV4dHtzbzF9Il0sWzIsMSwiXFx0ZXh0eyhuZXQtd2lkdGggbil9Il0sWzAsMSwiIV97XFx0ZXh0e3NvMX19Il0sWzEsMiwiXFx0ZXh0e25hdC1jb25zdH0gbiBtIl1d
\[\begin{tikzcd}[sep=large]
	&& {\text{so1}} \\
	{A_1 \times ... \times A_n \times \text{so1}} && {\text{(net-width n)}}
	\arrow["{!_{\text{so1}}}", from=2-1, to=1-3]
	\arrow["{\text{nat-const} n m}", from=1-3, to=2-3]
\end{tikzcd}\]
\item We compile the term \tcbox{(lamb-eq (ltm : nat-width n) (rtm : nat-width n)) : (coprod so1 so1)} to
% https://q.uiver.app/#q=WzAsMyxbMCwxLCJBXzEgXFx0aW1lcyAuLi4gXFx0aW1lcyBBX24gXFx0aW1lcyBcXHRleHR7c28xfSJdLFsyLDAsIihcXHRleHR7bmF0LXdpZHRoIG59KSBcXHRpbWVzIChcXHRleHR7bmF0LXdpZHRoIG59KSJdLFsyLDEsIlxcdGV4dHsobmV0LXdpZHRoIG4pfSJdLFswLDEsIiFfe1xcdGV4dHtzbzF9fSJdLFsxLDIsIlxcdGV4dHtuYXQtZXF9Il1d
\[\begin{tikzcd}[sep=large]
	&& {(\text{nat-width n}) \times (\text{nat-width n})} \\
	{A_1 \times ... \times A_n \times \text{so1}} && {\text{(net-width n)}}
	\arrow["{!_{\text{so1}}}", from=2-1, to=1-3]
	\arrow["{\text{nat-eq}}", from=1-3, to=2-3]
\end{tikzcd}\]
and similarlyty with less-than
\end{enumerate}

With this, we are done. One may notice that we actually skipped the \lamerr term, yet that is because what we described is the compilation of a term without errors. We have a predicate checking whether there is or is not an error term in a given term which decided how to compile it further. 

The compilation for terms with \lamerr is similar to the procedure described above, but wrapping everything recursively into a \tcbox{Maybe} monad.

\subsection{Geb $\to$ Seq$\N$}
\subsection{Seq$\N$ $\to$ Vamp-IR}

\section{Additional Features}
\subsection{Interpreters}
\subsection{Type-checking}
\subsection{Visualizer}

\section*{Acknowledgements}
The authors bear sole responsibility for any errors present within this
document. The fundamental theories and conjectures related to Geb are
attributed to Terence Rokop who is also the author of the Idris
implementation of Geb. The Lisp implementation reference was initially
introduced by Jeremy Ornelas, the current repository maintainer, and later
expanded upon by the first author. Anthony Hart contributed to the
implementation by correcting and adding an alternative pipeline as
presented in this document. Finally, the Lambda language showcased herein,
along with enhancements to typechecking, resulted from a collaboration with
the Juvix team.
\nocite{*}
\bibliography{ref.bib}

\end{document}
